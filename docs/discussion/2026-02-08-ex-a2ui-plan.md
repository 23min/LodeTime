# 2026-02-08 — ex_a2ui: Elixir A2UI Library Plan

## What is this?

A standalone Hex library that implements Google's A2UI (Agent-to-User Interface) protocol for Elixir/OTP applications. It provides the minimum needed to serve interactive, agent-driven UI surfaces from any BEAM application — without Phoenix, without LiveView, without heavyweight dependencies.

**Repository:** `ex_a2ui` on GitHub (to be created)
**Package:** `ex_a2ui` on Hex.pm
**License:** Apache 2.0 (matches A2UI spec license)

## Why build this?

1. **No Elixir A2UI renderer exists.** Official renderers: Lit, Angular, Flutter. React in progress. Elixir is absent.
2. **The BEAM is a natural fit.** Real-time, concurrent connections, fault-tolerant processes — exactly what an A2UI server needs.
3. **Lightweight alternative to Phoenix/LiveView.** Many BEAM apps need to surface a simple UI (dashboards, status pages, interactive reports) but don't want a full web framework.
4. **LodeTime needs it.** LodeTime's web interface (architecture graph, checkpoint reports, component status) is the first customer. Building it as a library forces clean separation between protocol and domain.
5. **Claim the namespace.** The Elixir A2UI space is unclaimed. First mover gets the obvious package name and community attention.

## Dependencies (minimal)

```elixir
# Required
{:bandit, "~> 1.0"},    # HTTP server
{:websock, "~> 0.5"},   # WebSocket behavior
{:plug, "~> 1.15"},     # Static file serving
{:jason, "~> 1.4"},     # JSON encoding/decoding
```

That's it. No Phoenix, no Ecto, no LiveView.

## Architecture

```
ex_a2ui/
  lib/
    a2ui.ex                     # Public API entry point
    a2ui/
      # Protocol layer (A2UI spec types)
      component.ex              # Component struct + standard type atoms
      surface.ex                # Surface struct (id, components, root)
      bound_value.ex            # BoundValue (literal, path, or both)
      action.ex                 # Action struct (name, context bindings)
      data_model.ex             # DataModel (JSON Pointer state store)
      catalog.ex                # Component catalog (standard + custom)
      message.ex                # Wire message types (surfaceUpdate, etc.)

      # Builder layer (convenience API)
      builder.ex                # Pipe-friendly surface construction

      # Encoding layer
      encoder.ex                # Elixir structs → A2UI JSON
      decoder.ex                # Incoming JSON → Elixir structs (userAction)

      # Server layer
      server.ex                 # Bandit endpoint config + supervision
      socket.ex                 # WebSock handler (push/receive A2UI messages)
      static.ex                 # Plug for serving client-side renderer assets

  priv/
    static/
      a2ui-renderer.html        # Minimal HTML page that loads Lit renderer
      # Lit renderer JS loaded from CDN or vendored

  test/
    a2ui/
      component_test.exs
      encoder_test.exs
      decoder_test.exs
      builder_test.exs
      socket_test.exs
```

## API design: three layers

### Layer 1: Structs (the protocol, always available)

Direct 1:1 mapping to A2UI JSON spec. Power users and code generators use this.

```elixir
%A2UI.Surface{
  id: "status",
  components: [
    %A2UI.Component{
      id: "title",
      type: :text,
      properties: %{
        text: %A2UI.BoundValue{literal: "System Status"}
      }
    },
    %A2UI.Component{
      id: "health",
      type: :text,
      properties: %{
        text: %A2UI.BoundValue{path: "/system/health"}
      }
    }
  ]
}
```

### Layer 2: Builder functions (convenience, recommended)

Pipe-friendly, reduces boilerplate, composable. This is what most users will reach for.

```elixir
alias A2UI.Builder, as: UI

UI.surface("status")
|> UI.text("title", "System Status")
|> UI.text("health", bind: "/system/health")
|> UI.button("check", "Run Check", action: "run_check")
|> UI.card("main", children: ["title", "health", "check"])
```

Each function returns the surface with the component added. Builder also supports setting data model values:

```elixir
UI.surface("status")
|> UI.text("health", bind: "/system/health")
|> UI.data("/system/health", "operational")
```

### Layer 3: DSL (deferred, not in v0.1)

Macro-based syntax. Only build if real users request it. The builder layer is sufficient for most use cases and avoids the complexity and community divisiveness of macros.

## Server integration

### Starting the A2UI server

```elixir
# In your application supervision tree
children = [
  {A2UI.Server, port: 4040, surfaces: MyApp.Surfaces}
]

Supervisor.start_link(children, strategy: :one_for_one)
```

### Defining surfaces

```elixir
defmodule MyApp.Surfaces do
  @behaviour A2UI.SurfaceProvider

  @impl true
  def surfaces, do: ["status", "detail"]

  @impl true
  def render("status", _params) do
    A2UI.Builder.surface("status")
    |> A2UI.Builder.text("title", "My App Status")
    |> A2UI.Builder.button("refresh", "Refresh", action: "refresh")
  end

  @impl true
  def handle_action("refresh", _context) do
    # Handle user clicking the refresh button
    # Return updated surface or {:update_data, path, value}
    {:ok, render("status", %{})}
  end
end
```

### Pushing updates

```elixir
# From anywhere in your app, push a data model update
A2UI.Server.push_data("status", "/system/health", "degraded")

# Or push an entirely new surface
A2UI.Server.push_surface("status", updated_surface)
```

### PubSub integration (optional)

```elixir
# If your app uses Phoenix.PubSub (standalone, no Phoenix needed)
{A2UI.Server, port: 4040, surfaces: MyApp.Surfaces, pubsub: MyApp.PubSub}

# Your app broadcasts changes
Phoenix.PubSub.broadcast(MyApp.PubSub, "a2ui:status", {:data_update, "/health", "ok"})

# A2UI.Server subscribes and pushes to connected clients automatically
```

## Custom components

For domain-specific rendering (graph visualizations, code diffs, timelines):

```elixir
# Register a custom component type
A2UI.Catalog.register(:graph, %{
  description: "Interactive graph visualization",
  properties: [:nodes, :edges, :layout],
  js_module: "GraphComponent"  # Client-side Web Component name
})

# Use it in a surface
UI.surface("architecture")
|> UI.custom(:graph, "arch-graph",
    nodes: bind("/graph/nodes"),
    edges: bind("/graph/edges"),
    layout: "dagre"
   )
```

The client-side custom component must be registered in the HTML page:

```html
<!-- In priv/static/a2ui-renderer.html or user's custom page -->
<script type="module">
  import { GraphComponent } from './components/graph.js';
  customElements.define('a2ui-graph', GraphComponent);
</script>
```

## Client-side renderer strategy

The library ships a minimal HTML page (`priv/static/a2ui-renderer.html`) that:

1. Loads Google's Lit-based A2UI renderer from CDN (or vendored JS)
2. Opens a WebSocket to the A2UI server
3. Renders surfaces as they arrive
4. Sends `userAction` events back over WebSocket

Users can replace this page entirely with their own renderer (React, Angular, Flutter, or custom). The library doesn't care what renders the JSON — it only produces valid A2UI messages and handles incoming actions.

**CDN vs vendored:**
- Default: CDN link to Google's Lit renderer (simplest, always up to date)
- Option: `mix a2ui.vendor` task to download and vendor the JS locally (for offline/airgapped use)

## Wire protocol

### Server → Client

Messages are JSONL over WebSocket, one JSON object per message:

```json
{"beginRendering": {"surfaceId": "status", "rootComponentId": "main"}}
```

```json
{"surfaceUpdate": {"surfaceId": "status", "components": [...]}}
```

```json
{"dataModelUpdate": {"surfaceId": "status", "data": {"/system/health": "ok"}}}
```

```json
{"deleteSurface": {"surfaceId": "status"}}
```

### Client → Server

```json
{"userAction": {"action": {"name": "run_check"}, "context": {...}}}
```

## What this is NOT

- Not a web framework (no routing, no templates, no sessions)
- Not a Phoenix replacement (Phoenix does 100x more)
- Not a LiveView alternative (LiveView is server-rendered HTML; this is declarative JSON)
- Not a full A2UI client/renderer (Google's Lit renderer handles that)
- Not tied to LodeTime (pure protocol library, any BEAM app can use it)

## Versioning strategy

- Library version: standard SemVer (`0.1.0`, `0.2.0`, etc.)
- A2UI spec version: tracked in `@a2ui_spec_version` module attribute and exposed via `A2UI.spec_version/0`
- Initial target: A2UI v0.8 (current public preview)
- When A2UI goes v0.9 or v1.0: major version bump in the library if breaking

## Development plan

### v0.0.1 — Claim namespace (week 1)

- README with vision and examples
- `mix.exs` with deps declared
- Basic structs: `Component`, `Surface`, `BoundValue`, `Action`
- `Encoder` that produces valid A2UI JSON
- Tests: encoder output matches A2UI spec examples
- Publish to Hex

### v0.1.0 — Usable server (week 2-3)

- `Builder` module with pipe-friendly API
- `Decoder` for incoming `userAction` messages
- `Socket` WebSocket handler (push surfaces, receive actions)
- `Server` with Bandit endpoint and supervision
- `Static` plug for serving renderer HTML page
- `SurfaceProvider` behaviour
- Ship with default `a2ui-renderer.html` (Lit-based)
- Integration test: start server, connect WebSocket, render surface, click button, receive action

### v0.2.0 — Real-time and custom (week 4+)

- `push_data` / `push_surface` for live updates
- PubSub integration (optional)
- Custom component registration via `Catalog`
- `DataModel` with JSON Pointer resolution
- Streaming support (incremental surface building)
- Documentation on Hex

### v0.3.0+ — Driven by LodeTime usage

- API refinements based on building LodeTime's surfaces
- Cytoscape.js graph custom component (may live in LodeTime, not in the library)
- Performance tuning for large surfaces
- Multi-surface management (switching between views)

## Relationship to LodeTime

```
ex_a2ui (Hex library)
  ├── Protocol types, encoder, decoder
  ├── Builder API
  ├── WebSocket server (Bandit)
  └── Default Lit renderer page

LodeTime (application)
  ├── Depends on ex_a2ui
  ├── Implements SurfaceProvider for:
  │     ├── StatusSurface (component health, runtime state)
  │     ├── CheckpointSurface (validation findings, action buttons)
  │     └── GraphSurface (architecture graph, Cytoscape.js)
  ├── Registers custom components (graph visualization)
  ├── Bridges Graph.Server / State.Server → A2UI surfaces
  └── Handles domain-specific user actions
```

LodeTime is the first (and for now, only) customer. The library API is shaped by LodeTime's needs but doesn't contain any LodeTime concepts.

**Development workflow:**
- Both repos on the development machine
- `ex_a2ui` cloned to `/workspace-data/ex_a2ui` (persistent mount, survives container rebuild)
- LodeTime's `mix.exs` uses path dependency during co-development:
  ```elixir
  {:ex_a2ui, path: "/workspace-data/ex_a2ui"}
  ```
- Switch to Hex dependency for releases:
  ```elixir
  {:ex_a2ui, "~> 0.1"}
  ```

## Risks

| Risk | Severity | Mitigation |
|------|----------|------------|
| A2UI spec changes (v0.8 → v1.0) | Medium | Isolate spec mapping in encoder/decoder; bump major version on breaking changes |
| Small audience initially | Low | LodeTime is primary customer; community adoption is a bonus, not a requirement |
| API design wrong on first try | Medium | Ship v0.0.x early; use LodeTime as proving ground; iterate fast before v1.0 |
| Lit renderer CDN dependency | Low | Offer vendoring via mix task; document self-hosting |
| Maintenance burden | Medium | Keep scope minimal; resist feature requests that belong in application code |

## Open questions

1. **Package name:** `ex_a2ui` or `a2ui`? Elixir convention varies — `ex_` prefix is common for ports/wrappers (ex_aws, ex_machina), but `a2ui` is shorter and the library isn't wrapping an existing tool.

2. **Renderer asset strategy:** Ship the Lit renderer JS vendored in `priv/static/`, or load from CDN by default? Vendoring adds size but works offline. CDN is simpler but adds an external dependency at runtime.

3. **Behaviour vs module config:** Should surface providers implement a behaviour (`@behaviour A2UI.SurfaceProvider`) or register via config? Behaviour is more Elixir-idiomatic; config is more flexible for dynamic surfaces.

4. **Testing utilities:** Should the library ship test helpers (e.g., `A2UI.Test.assert_surface_contains/2`, `A2UI.Test.simulate_action/2`)? Useful for downstream apps but adds maintenance scope.

5. **Hex publish cadence:** Publish every meaningful change (fast feedback, visible progress) or batch into fewer releases (less noise)?

## References

- [A2UI specification](https://a2ui.org/)
- [A2UI GitHub (Google)](https://github.com/google/A2UI)
- [A2UI Renderer Development Guide](https://a2ui.org/guides/renderer-development/)
- [A2UI Components & Structure](https://a2ui.org/concepts/components/)
- [Bandit HTTP Server](https://github.com/mtrudel/bandit)
- [WebSock Elixir](https://github.com/mtrudel/websock)
- [LodeTime A2UI Integration Research](./2026-02-08-a2ui-integration-research.md)
